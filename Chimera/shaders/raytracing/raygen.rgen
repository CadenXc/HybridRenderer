#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#include "ShaderCommon.h"

layout(set = 0, binding = 0) uniform GlobalUBO {
    UniformBufferObject ubo;
} global;

layout(set = 1, binding = 0) uniform accelerationStructureEXT topLevelAS;

layout(set = 2, binding = 0, rgba16f) uniform image2D rtShadowAO;
layout(set = 2, binding = 1) uniform sampler2D gNormal;
layout(set = 2, binding = 2) uniform sampler2D gDepth;

layout(location = 0) rayPayloadEXT int isShadowed;

void main() 
{
    const vec2 inUV = (vec2(gl_LaunchIDEXT.xy) + vec2(0.5)) / vec2(gl_LaunchSizeEXT.xy);
    
    float depth = texture(gDepth, inUV).r;
    if (depth == 0.0) {
        imageStore(rtShadowAO, ivec2(gl_LaunchIDEXT.xy), vec4(1.0, 1.0, 0.0, 1.0));
        return;
    }

    vec3 worldPos = GetWorldPos(depth, inUV, global.ubo.viewProjInverse);
    vec3 normal = normalize(texture(gNormal, inUV).xyz * 2.0 - 1.0);

    // 1. Ray Traced Shadow
    vec3 lightDir = normalize(global.ubo.directionalLight.direction.xyz);
    vec3 origin = worldPos + normal * 0.005; // Bias
    
    isShadowed = 1; // 假设有阴影
    traceRayEXT(topLevelAS, gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT,
                0xFF, 0, 0, 1, origin, 0.001, lightDir, 10000.0, 0);

    float shadow = (isShadowed == 1) ? 0.0 : 1.0;
    float ao = 1.0; 

    imageStore(rtShadowAO, ivec2(gl_LaunchIDEXT.xy), vec4(shadow, ao, 0.0, 1.0));
}