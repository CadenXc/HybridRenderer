#version 460
#extension GL_EXT_ray_tracing : require

// ======================= [Set 0] 全局资源 (与 ResourceManager 对应) =======================
layout(binding = 0, set = 0) uniform CameraProperties 
{
    mat4 view;
    mat4 proj;
    mat4 prevView;
    mat4 prevProj;
    vec4 cameraPos;
    vec4 lightPos;
    float time;
    int  frameCount;
} cam;

// ======================= [Set 1] RenderGraph 注入资源 (与 RayTracedRenderPath 对应) =======================
layout(binding = 0, set = 1) uniform accelerationStructureEXT topLevelAS;

// [Binding 1] 当前帧输出
layout(binding = 1, set = 1, rgba8) uniform image2D image;

// ======================= 随机数算法 =======================
uint tea(uint val0, uint val1)
{
    uint v0 = val0; uint v1 = val1; uint s0 = 0;
    for(uint n = 0; n < 16; n++) {
        s0 += 0x9e3779b9;
        v0 += ((v1 << 4) + 0xa341316c) ^ (v1 + s0) ^ ((v1 >> 5) + 0xc8013ea4);
        v1 += ((v0 << 4) + 0xa341316c) ^ (v1 + s0) ^ ((v1 >> 5) + 0xc8013ea4);
    }
    return v0;
}

float rnd(inout uint prev)
{
    prev = prev * 1664525u + 1013904223u;
    return float(prev & 0x00FFFFFF) / float(0x01000000);
}

// ======================= Payload =======================
struct HitPayload
{
    vec3 color;
    vec3 normal;
    vec3 worldPos;
    int  depth;
};

layout(location = 0) rayPayloadEXT HitPayload payload;

void main() 
{
    // 1. 初始化随机种子
    uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, cam.frameCount);

    // 2. 射线生成
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    mat4 viewInverse = inverse(cam.view);
    mat4 projInverse = inverse(cam.proj);

    vec4 origin = viewInverse * vec4(0, 0, 0, 1);
    vec4 target = projInverse * vec4(d.x, d.y, 1, 1);
    vec4 direction = viewInverse * vec4(normalize(target.xyz / target.w), 0);

    vec3 rayOrigin = origin.xyz;
    vec3 rayDir    = normalize(direction.xyz);

    // ======================= 路径追踪 =======================
    payload.depth = 0;
    traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, rayOrigin, 0.001, rayDir, 10000.0, 0);

    vec3 newColor = payload.color; 

    if (payload.depth == 1) // 击中物体
    {
        vec3 hitPos = payload.worldPos;
        vec3 hitNormal = payload.normal;
        vec3 albedo = payload.color; 

        // 简单的直接光
        vec3 L = normalize(cam.lightPos.xyz - hitPos);
        float distToLight = length(cam.lightPos.xyz - hitPos);

        vec3 shadowOrigin = hitPos + hitNormal * 0.001;
        payload.depth = 0; 
        traceRayEXT(topLevelAS, gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, shadowOrigin, 0.001, L, distToLight, 0);

        float shadowFactor = (payload.depth == 1) ? 0.2 : 1.0;
        newColor = albedo * shadowFactor * max(dot(hitNormal, L), 0.1);
    }

    // Gamma 校正并输出
    vec3 displayColor = pow(newColor, vec3(1.0 / 2.2));
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(displayColor.rgb, 1.0));
}
