#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#include "ShaderCommon.h"

layout(set = 0, binding = 0) uniform GlobalUBO {
    UniformBufferObject ubo;
} global;

layout(set = 1, binding = 0) uniform accelerationStructureEXT topLevelAS;

layout(set = 2, binding = 0, rgba16f) uniform image2D rtShadowAO;
layout(set = 2, binding = 1) uniform sampler2D gNormal;
layout(set = 2, binding = 2) uniform sampler2D gDepth;

layout(location = 0) rayPayloadEXT int isShadowed;

uint InitSeed(uint seed, uint salt) 
{
    return seed ^ salt;
}

uint NextRandom(inout uint seed) 
{
    seed = seed * 1664525u + 1013904223u;
    return seed;
}

float RandomFloat(inout uint seed) 
{
    return float(NextRandom(seed)) / 4294967296.0;
}

vec3 SquareToUniformCone(vec2 sampleIn, float cosThetaMax) 
{
    float cosTheta = (1.0 - sampleIn.x) + sampleIn.x * cosThetaMax;
    float sinTheta = sqrt(max(0.0, 1.0 - cosTheta * cosTheta));
    float phi = sampleIn.y * 2.0 * 3.14159265359;
    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
}

void main() 
{
    const vec2 inUV = (vec2(gl_LaunchIDEXT.xy) + vec2(0.5)) / vec2(gl_LaunchSizeEXT.xy);
    
    float depth = texture(gDepth, inUV).r;
    if (depth == 0.0) 
    {
        imageStore(rtShadowAO, ivec2(gl_LaunchIDEXT.xy), vec4(1.0, 1.0, 0.0, 1.0));
        return;
    }

    vec3 worldPos = GetWorldPos(depth, inUV, global.ubo.viewProjInverse);
    vec3 normal = normalize(texture(gNormal, inUV).xyz * 2.0 - 1.0);

    // Random Jitter for Soft Shadows
    uint seed = InitSeed(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, global.ubo.frameCount);
    vec2 randSample = vec2(RandomFloat(seed), RandomFloat(seed));

    // 1. Ray Traced Shadow
    vec3 L = normalize(global.ubo.directionalLight.direction.xyz);
    
    // Jitter L based on lightRadius
    if (global.ubo.lightRadius > 0.0)
    {
        vec3 tangent, bitangent;
        if (abs(L.z) > 0.9) 
        {
            tangent = vec3(1, 0, 0);
        }
        else 
        {
            tangent = vec3(0, 0, 1);
        }
        bitangent = normalize(cross(L, tangent));
        tangent = cross(bitangent, L);

        // Map to cone around L
        float cosThetaMax = cos(global.ubo.lightRadius); // radius as angle
        vec3 coneSample = SquareToUniformCone(randSample, cosThetaMax);
        L = normalize(coneSample.x * tangent + coneSample.y * bitangent + coneSample.z * L);
    }

    vec3 origin = worldPos + normal * 0.005; // Bias
    
    isShadowed = 1; // Assume shadowed
    traceRayEXT(topLevelAS, gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT,
                0xFF, 0, 0, 1, origin, 0.001, L, 10000.0, 0);

    float shadow = (isShadowed == 1) ? 0.0 : 1.0;
    float ao = 1.0; 

    imageStore(rtShadowAO, ivec2(gl_LaunchIDEXT.xy), vec4(shadow, ao, 0.0, 1.0));
}