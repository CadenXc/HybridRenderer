#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_buffer_reference2 : require

#include "ShaderCommon.h"

layout(buffer_reference, scalar) readonly buffer VertexBufferRef { GpuVertex v[]; };
layout(buffer_reference, scalar) readonly buffer IndexBufferRef { uint i[]; };

hitAttributeEXT vec2 attribs;

layout(set = 1, binding = 1, scalar) readonly buffer MaterialBuffer { GpuMaterial m[]; } materialBuffer;
layout(set = 1, binding = 2, scalar) readonly buffer PrimitiveBuffer { GpuPrimitive primitives[]; } primBuf;
layout(set = 1, binding = 3) uniform sampler2D textureArray[];

void main()
{
    uint objId = gl_InstanceCustomIndexEXT;
    GpuPrimitive prim = primBuf.primitives[objId];
    GpuMaterial mat = materialBuffer.m[prim.materialIndex];
    
    if (mat.albedoTex >= 0)
    {
        IndexBufferRef indices = IndexBufferRef(prim.indexAddress);
        uint i0 = indices.i[3 * gl_PrimitiveID];
        uint i1 = indices.i[3 * gl_PrimitiveID + 1];
        uint i2 = indices.i[3 * gl_PrimitiveID + 2];

        VertexBufferRef vertices = VertexBufferRef(prim.vertexAddress);
        vec2 uv0 = vertices.v[i0].texCoord;
        vec2 uv1 = vertices.v[i1].texCoord;
        vec2 uv2 = vertices.v[i2].texCoord;

        vec3 barycentrics = vec3(1.0 - attribs.x - attribs.y, attribs.x, attribs.y);
        vec2 uv = uv0 * barycentrics.x + uv1 * barycentrics.y + uv2 * barycentrics.z;

        float alpha = texture(textureArray[nonuniformEXT(mat.albedoTex)], uv).a;

        if (alpha < 0.5)
        {
            ignoreIntersectionEXT;
        }
    }
}
