#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#include "ShaderCommon.h"

layout(set = 0, binding = 0) uniform GlobalUBO 
{
    UniformBufferObject ubo;
} global;

layout(set = 1, binding = 0) uniform accelerationStructureEXT topLevelAS;

layout(set = 2, binding = 0, rgba16f) uniform image2D rtFinalColor;

layout(location = 0) rayPayloadEXT HitPayload payload;

layout(push_constant) uniform PushConstants 
{
    int useAlphaTest;
} pc;

void main() 
{
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    vec4 origin = global.ubo.camera.viewInverse * vec4(0, 0, 0, 1);
    vec4 target = global.ubo.camera.projInverse * vec4(d.x, d.y, 1, 1);
    vec4 direction = global.ubo.camera.viewInverse * vec4(normalize(target.xyz), 0);

    payload.hit = false;
    payload.color = vec3(0.0);

    // [CORE LOGIC] If Alpha Test is disabled, force all geometry to be OPAQUE for performance
    uint rayFlags = gl_RayFlagsNoneEXT;
    if (pc.useAlphaTest == 0)
    {
        rayFlags |= gl_RayFlagsOpaqueEXT;
    }

    traceRayEXT(topLevelAS, rayFlags, 0xFF, 0, 0, 0, origin.xyz, 0.001, direction.xyz, 10000.0, 0);

    vec3 color = payload.color;
    if (!payload.hit) 
    {
        // Use the dynamic global background color
        color = global.ubo.clearColor.rgb;
    } 
    else 
    {
        // Simple lighting at hit point
        vec3 lightDir = normalize(global.ubo.sunLight.direction.xyz);
        float diff = max(dot(payload.normal, -lightDir), 0.0);
        color = payload.color * (0.2 + 0.8 * diff);
    }

    imageStore(rtFinalColor, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.0));
}
