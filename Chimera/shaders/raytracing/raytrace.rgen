#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#include "ShaderCommon.h"

layout(set = 0, binding = 0) uniform GlobalUBO {
    UniformBufferObject ubo;
} global;

layout(set = 1, binding = 0) uniform accelerationStructureEXT topLevelAS;

layout(set = 2, binding = 0, rgba16f) uniform image2D rtFinalColor;

layout(location = 0) rayPayloadEXT HitPayload payload;

void main() 
{
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    vec4 origin = global.ubo.viewInverse * vec4(0, 0, 0, 1);
    vec4 target = global.ubo.projInverse * vec4(d.x, d.y, 1, 1);
    vec4 direction = global.ubo.viewInverse * vec4(normalize(target.xyz), 0);

    payload.hit = false;
    payload.color = vec3(0.0);

    traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, origin.xyz, 0.001, direction.xyz, 10000.0, 0);

    vec3 color = payload.color;
    if (!payload.hit) {
        // Sky color fallback
        float t = 0.5 * (direction.y + 1.0);
        color = (1.0 - t) * vec3(1.0) + t * vec3(0.5, 0.7, 1.0);
    } else {
        // Simple lighting at hit point
        vec3 lightDir = normalize(global.ubo.directionalLight.direction.xyz);
        float diff = max(dot(payload.normal, -lightDir), 0.0);
        color = payload.color * (0.2 + 0.8 * diff);
    }

    imageStore(rtFinalColor, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.0));
}
