#version 450

layout(local_size_x = 16, local_size_y = 16) in;

// In/Out descriptors
layout(binding = 0, rgba16f) uniform readonly image2D inputImage;
layout(binding = 1, rgba16f) uniform writeonly image2D outputImage;
layout(binding = 2, rgba16f) uniform image2D sceneImage; // Read-write for final composition

layout(push_constant) uniform PushConstants {
    int mode; // 0: Extract, 1: Horizontal Blur, 2: Vertical Blur, 3: Composite
    float threshold;
    float intensity;
} pc;

float luma(vec3 color) {
    return dot(color, vec3(0.2126, 0.7152, 0.0722));
}

void main() {
    ivec2 texel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(sceneImage);
    if (texel.x >= size.x || texel.y >= size.y) return;

    if (pc.mode == 0) { // Extract Brightness
        vec3 color = imageLoad(inputImage, texel).rgb;
        float brightness = luma(color);
        if (brightness > pc.threshold) {
            imageStore(outputImage, texel, vec4(color, 1.0));
        } else {
            imageStore(outputImage, texel, vec4(0.0, 0.0, 0.0, 1.0));
        }
    } 
    else if (pc.mode == 1 || pc.mode == 2) { // Gaussian Blur (Separable)
        float weights[5] = float[](0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);
        vec3 result = imageLoad(inputImage, texel).rgb * weights[0];
        ivec2 direction = (pc.mode == 1) ? ivec2(1, 0) : ivec2(0, 1);

        for (int i = 1; i < 5; ++i) {
            result += imageLoad(inputImage, texel + direction * i).rgb * weights[i];
            result += imageLoad(inputImage, texel - direction * i).rgb * weights[i];
        }
        imageStore(outputImage, texel, vec4(result, 1.0));
    }
    else if (pc.mode == 3) { // Composite (Additive)
        vec3 sceneColor = imageLoad(sceneImage, texel).rgb;
        vec3 bloomColor = imageLoad(inputImage, texel).rgb;
        imageStore(sceneImage, texel, vec4(sceneColor + bloomColor * pc.intensity, 1.0));
    }
}
