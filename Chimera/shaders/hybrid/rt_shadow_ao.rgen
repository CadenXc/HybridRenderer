#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : require

#include "../common/structures.glsl"

struct DirectionalLight { mat4 projview; vec4 direction; vec4 color; vec4 intensity; };
layout(binding = 0, set = 0) uniform CameraProperties {
    mat4 view; mat4 proj; mat4 viewInverse; mat4 projInverse; mat4 viewProjInverse;
    mat4 prevView; mat4 prevProj; DirectionalLight directionalLight;
    vec2 displaySize; vec2 displaySizeInverse; uint frameIndex; uint frameCount; uint displayMode; vec4 cameraPos;
} cam;

// --- Unified Ray Tracing Layout (Set 1) ---
layout(binding = 0, set = 1) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 1, rg16f) uniform image2D outShadowAO; 
layout(binding = 2, set = 1, scalar) buffer MaterialBuffer { PBRMaterial m[]; } materials;
layout(binding = 3, set = 1, scalar) buffer InstanceDataBuffer { RTInstanceData i[]; } instances;
layout(binding = 4, set = 1) uniform sampler2D textureArray[];
layout(binding = 5, set = 1, rgba16f) uniform image2D outReflections;

// --- Hybrid Specific Inputs ---
layout(binding = 6, set = 1) uniform sampler2D samplerNormal;
layout(binding = 7, set = 1) uniform sampler2D samplerDepth;
layout(binding = 8, set = 1) uniform sampler2D samplerMaterial;

layout(location = 0) rayPayloadEXT HitPayload reflectPayload;
layout(location = 1) rayPayloadEXT bool isShadowed;

// RNG
uint tea(uint val0, uint val1) {
    uint v0 = val0; uint v1 = val1; uint s0 = 0;
    for(uint n = 0; n < 16; n++) {
        s0 += 0x9e3779b9;
        v0 += ((v1 << 4) + 0xa341316c) ^ (v1 + s0) ^ ((v1 >> 5) + 0xc8013ea4);
        v1 += ((v0 << 4) + 0xa341316c) ^ (v1 + s0) ^ ((v1 >> 5) + 0xc8013ea4);
    }
    return v0;
}
float rnd(inout uint seed) { seed = (seed * 1664525u + 1013904223u); return float(seed & 0x00FFFFFF) / float(0x01000000); }
vec3 getCosSample(inout uint seed, vec3 n) {
    float u1 = rnd(seed); float u2 = rnd(seed);
    float r = sqrt(u1); float phi = 6.28318530718 * u2;
    vec3 localDir = vec3(r * cos(phi), r * sin(phi), sqrt(1.0 - u1));
    vec3 up = abs(n.z) < 0.999 ? vec3(0, 0, 1) : vec3(1, 0, 0);
    vec3 tangent = normalize(cross(up, n));
    vec3 bitangent = cross(n, tangent);
    return tangent * localDir.x + bitangent * localDir.y + n * localDir.z;
}

void main() {
    ivec2 pixel = ivec2(gl_LaunchIDEXT.xy);
    vec2 uv = (vec2(pixel) + 0.5) / vec2(gl_LaunchSizeEXT.xy);

    float depth = texture(samplerDepth, uv).r;
    if (depth == 1.0) {
        imageStore(outShadowAO, pixel, vec4(1.0, 1.0, 0.0, 0.0));
        imageStore(outReflections, pixel, vec4(0.0));
        return;
    }

    vec3 normal = texture(samplerNormal, uv).rgb * 2.0 - 1.0;
    vec4 matParams = texture(samplerMaterial, uv);
    float roughness = matParams.r;
    
    vec4 clipPos = vec4(uv * 2.0 - 1.0, depth, 1.0);
    vec4 worldPos = cam.viewProjInverse * clipPos;
    worldPos /= worldPos.w;

    uint seed = tea(pixel.y * int(gl_LaunchSizeEXT.x) + pixel.x, cam.frameCount);

    // 1. Shadow
    vec3 L = normalize(-cam.directionalLight.direction.xyz);
    isShadowed = true;
    traceRayEXT(topLevelAS, gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT, 0xFF, 0, 0, 1, worldPos.xyz + normal * 0.001, 0.001, L, 10000.0, 1);
    float shadow = isShadowed ? 0.0 : 1.0;

    // 2. AO
    float ao = 0.0;
    isShadowed = true;
    traceRayEXT(topLevelAS, gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT, 0xFF, 0, 0, 1, worldPos.xyz + normal * 0.001, 0.001, getCosSample(seed, normal), 2.0, 1);
    ao = isShadowed ? 0.0 : 1.0;

    // 3. Reflection
    vec3 reflectionColor = vec3(0.0);
    if (roughness < 0.5) {
        vec3 V = normalize(cam.cameraPos.xyz - worldPos.xyz);
        vec3 R = reflect(-V, normalize(normal));
        reflectPayload.hit = false;
        reflectPayload.color = vec3(0.0);
        traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, worldPos.xyz + normal * 0.001, 0.001, R, 10000.0, 0);
        reflectionColor = reflectPayload.color;
    }

    if (cam.frameCount > 1) {
        vec2 oldSAO = imageLoad(outShadowAO, pixel).rg;
        vec3 oldRef = imageLoad(outReflections, pixel).rgb;
        float a = 1.0 / float(cam.frameCount);
        imageStore(outShadowAO, pixel, vec4(mix(oldSAO, vec2(shadow, ao), a), 0.0, 0.0));
        imageStore(outReflections, pixel, vec4(mix(oldRef, reflectionColor, a), 1.0));
    } else {
        imageStore(outShadowAO, pixel, vec4(shadow, ao, 0.0, 0.0));
        imageStore(outReflections, pixel, vec4(reflectionColor, 1.0));
    }
}