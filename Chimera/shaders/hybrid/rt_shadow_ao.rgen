#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : require

#include "ShaderCommon.h"

layout(binding = 0, set = 0) uniform GlobalUBO {
    UniformBufferObject cam;
} ubo;

// --- Standard Set 1 (Scene) ---
layout(binding = 0, set = 1) uniform accelerationStructureEXT SceneAS;
layout(binding = 1, set = 1, scalar) readonly buffer MaterialBuffer { PBRMaterial m[]; } materialBuffer;
layout(binding = 2, set = 1, scalar) readonly buffer InstanceBuffer { RTInstanceData i[]; } instanceBuffer;
layout(binding = 3, set = 1) uniform sampler2D textureArray[];

// --- Set 2: Pass Specific ---
layout(binding = 0, set = 2, rg16f) uniform image2D outShadowAO; 
layout(binding = 1, set = 2, rgba16f) uniform image2D outReflections;
layout(binding = 2, set = 2) uniform sampler2D inNormal;
layout(binding = 3, set = 2) uniform sampler2D inDepth;
layout(binding = 4, set = 2) uniform sampler2D inMaterial;

layout(location = 0) rayPayloadEXT HitPayload reflectPayload;
layout(location = 1) rayPayloadEXT bool isShadowed;

// RNG
uint tea(uint val0, uint val1) {
    uint v0 = val0; uint v1 = val1; uint s0 = 0;
    for(uint n = 0; n < 16; n++) {
        s0 += 0x9e3779b9;
        v0 += ((v1 << 4) + 0xa341316c) ^ (v1 + s0) ^ ((v1 >> 5) + 0xc8013ea4);
        v1 += ((v0 << 4) + 0xa341316c) ^ (v1 + s0) ^ ((v1 >> 5) + 0xc8013ea4);
    }
    return v0;
}
float rnd(inout uint seed) { seed = (seed * 1664525u + 1013904223u); return float(seed & 0x00FFFFFF) / float(0x01000000); }
vec3 getCosSample(inout uint seed, vec3 n) {
    float u1 = rnd(seed); float u2 = rnd(seed);
    float r = sqrt(u1); float phi = 6.28318530718 * u2;
    vec3 localDir = vec3(r * cos(phi), r * sin(phi), sqrt(1.0 - u1));
    vec3 up = abs(n.z) < 0.999 ? vec3(0, 0, 1) : vec3(1, 0, 0);
    vec3 tangent = normalize(cross(up, n));
    vec3 bitangent = cross(n, tangent);
    return tangent * localDir.x + bitangent * localDir.y + n * localDir.z;
}

void main() 
{
    ivec2 pixel = ivec2(gl_LaunchIDEXT.xy);
    vec2 uv = (vec2(pixel) + 0.5) / vec2(gl_LaunchSizeEXT.xy);

    float depth = texture(inDepth, uv).r;
    if (depth <= 0.00001) 
    {
        imageStore(outShadowAO, pixel, vec4(1.0, 1.0, 0.0, 0.0)); // No shadow/AO in sky
        imageStore(outReflections, pixel, vec4(0.0));
        return;
    }

    vec3 normal = texture(inNormal, uv).rgb;
    vec4 matParams = texture(inMaterial, uv);
    float roughness = matParams.r; // R is Roughness
    
    vec3 worldPos = GetWorldPos(depth, uv, ubo.cam.viewProjInverse);

    // --- IMPROVED BIASING ---
    // A small bias is needed to avoid self-intersection.
    // For reconstructed depth, 0.01-0.02 is usually safe.
    vec3 rayOrigin = worldPos + normal * 0.015; 

    uint seed = tea(pixel.y * int(gl_LaunchSizeEXT.x) + pixel.x, ubo.cam.frameCount);

    // 1. Shadow Ray
    vec3 L = normalize(-ubo.cam.directionalLight.direction.xyz);
    isShadowed = true; 
    traceRayEXT(SceneAS, 
        gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT, 
        0xFF, 0, 0, 1, 
        rayOrigin, 0.001, L, 10000.0, 1);
    float shadow = isShadowed ? 0.0 : 1.0;

    // 2. AO Ray
    isShadowed = true; 
    vec3 aoDir = getCosSample(seed, normal);
    traceRayEXT(SceneAS, 
        gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT, 
        0xFF, 0, 0, 1, 
        rayOrigin, 0.001, aoDir, 3.0, 1); // Increased distance to 3.0
    float ao = isShadowed ? 0.0 : 1.0;

    // 3. Reflection
    vec3 reflectionColor = vec3(0.0);
    if (roughness < 0.5) 
    {
        vec3 V = normalize(ubo.cam.cameraPos.xyz - worldPos.xyz);
        vec3 R = reflect(-V, normalize(normal));
        reflectPayload.hit = false; 
        reflectPayload.color = vec3(0.0);
        traceRayEXT(SceneAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, rayOrigin, 0.001, R, 10000.0, 0);
        reflectionColor = reflectPayload.color;
    }

    imageStore(outShadowAO, pixel, vec4(shadow, ao, 0.0, 0.0));
    imageStore(outReflections, pixel, vec4(reflectionColor, 1.0));
}
