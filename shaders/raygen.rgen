#version 460
#extension GL_EXT_ray_tracing : require

// ======================= 绑定资源 =======================
layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba8) uniform image2D image;

layout(binding = 0, set = 1) uniform CameraProperties 
{
    mat4 model;
    mat4 view;
    mat4 proj;
} cam;

// ======================= Payload 定义 =======================
struct HitPayload
{
    vec3 color;
    vec3 normal;
    vec3 worldPos;
    int  depth;
};

layout(location = 0) rayPayloadEXT HitPayload payload;

void main() 
{
    // 1. 计算射线参数
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    mat4 viewInverse = inverse(cam.view);
    mat4 projInverse = inverse(cam.proj);

    vec4 origin = viewInverse * vec4(0, 0, 0, 1);
    vec4 target = projInverse * vec4(d.x, d.y, 1, 1);
    vec4 direction = viewInverse * vec4(normalize(target.xyz), 0);

    // ======================= 第一次发射：主光线 =======================
    // 初始化 Payload
    payload.color = vec3(0.0);
    payload.normal = vec3(0.0);
    payload.depth = 0;

    traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, origin.xyz, 0.001, direction.xyz, 10000.0, 0);

    // 保存主光线击中结果
    vec3 primaryColor = payload.color;
    vec3 hitNormal = payload.normal;
    vec3 hitPos = payload.worldPos;
    int  didHit = payload.depth;

    vec3 finalColor = vec3(0.0);

    if (didHit == 1)
    {
        // ---------------------------------------------------------
        // [新增] 阴影计算 (Shadow Ray)
        // ---------------------------------------------------------
        float shadowFactor = 1.0;
        vec3 lightPos = vec3(2.0, 5.0, 5.0); // 必须与 closesthit 里的光源位置一致！
        vec3 L = normalize(lightPos - hitPos);
        float distToLight = length(lightPos - hitPos);

        // 偏移原点，防止自我遮挡 (Shadow Acne)
        vec3 shadowOrigin = hitPos + hitNormal * 0.01;

        // 重置 Payload 状态，准备探测
        payload.depth = 0; 

        // 发射阴影射线
        // flags: TerminateOnFirstHit (只要撞到一个东西就停，不用算最近的，优化性能)
        traceRayEXT(
            topLevelAS, 
            gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT, 
            0xFF, 0, 0, 0, 
            shadowOrigin, 
            0.01, 
            L, 
            distToLight, // 射线长度 = 到光源的距离
            0
        );

        // 如果 depth 变回了 1，说明射线在到达光源前撞到了东西 -> 有阴影
        if (payload.depth == 1)
        {
            shadowFactor = 0.3; // 阴影区域变暗 (0.3 是环境光亮度)
        }

        // 应用阴影
        primaryColor *= shadowFactor;

        // ---------------------------------------------------------
        // [原有] 反射计算 (Reflection Ray)
        // ---------------------------------------------------------
        vec3 reflectDir = reflect(direction.xyz, hitNormal);
        vec3 reflectOrigin = hitPos + hitNormal * 0.01;

        payload.color = vec3(0.0);
        payload.depth = 0;

        traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, reflectOrigin, 0.01, reflectDir, 10000.0, 0);

        vec3 reflectionColor = payload.color;
        
        // 混合：阴影后的本色 + 反射色
        finalColor = primaryColor * 0.6 + reflectionColor * 0.4;
    }
    else
    {
        // 没打中任何物体，显示背景色
        finalColor = primaryColor;
    }

    // ======================= 输出结果 =======================
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(finalColor.bgr, 1.0));
}